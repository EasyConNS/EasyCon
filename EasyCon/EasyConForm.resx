<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="menuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <data name="textBoxScriptHelp.Text" xml:space="preserve">
    <value>所有代码不区分大小写，支持前置后置空格，支持行内注释。

【注释】
语法：# 注释内容
（多写注释是个好习惯，尤其是分享给别人的时候）

【输出】
语法：PRINT 输出内容
（联机模式专用，在控制台显示文字）

【按键】
语法：键位 [持续时间(ms)|DOWN|UP]
（键位可以取A、B、X、Y、L、R、ZL、ZR、MINUS(-)、PLUS(+)、LCLICK(按左摇杆)、RCLICK(按右摇杆)、HOME(返回系统)、CAPTURE(截屏)、LEFT、RIGHT、UP、DOWN；持续时间省略则为默认50ms）
示例：A（按下A键50毫秒）
示例：HOME 1000（按下Home键1秒）
示例：LEFT DOWN（按住左十字键，需要手动用LEFT UP松开）

【摇杆】
语法：LS|RS 方向|角度 [, 持续时间(ms)]
语法：LS|RS RESET
（LS左摇杆，RS右摇杆；方向可取UP、DOWN、LEFT、RIGHT；角度可取0~360，以右侧为0度，逆时针旋转；持续时间省略则一直保持，直到用RESET恢复原位）
示例：RS UP,50（右摇杆上推50毫秒）
示例：RS DOWN,2000（右摇杆下推2秒）
示例：LS 135（左摇杆左上方向，保持不动）
示例：LS RESET（左摇杆恢复原位）

【等待】
语法：[WAIT] 等待时间(ms)
示例：WAIT 500
示例：2000

【循环】
语法：
FOR [循环次数]
...
NEXT
（省略循环次数则无限循环）

---------------- 进阶用法 ----------------

注意，变量运算容易消耗多条指令，可能导致程序过大无法烧录，请节约使用。

【常量】
语法：常量名 = 值
（常量名必须以下划线“_”开头，可包含英文、数字或汉字，中间不能有空格，且名称本身区分大小写；值必须是非负整数；常量一旦定义就不能修改，可用来替换代码中任何数值）
示例：
_孵蛋个数 = 150
FOR _孵蛋个数
...
NEXT

【变量】
变量名语法：$索引
32位变量名语法：$$索引
（变量不支持自定义命名，只能使用数字编号；变量名必须以“$”开头，后加索引，取值0~7；其中$0常驻为0，无法修改，$7用于存储计算中间值，尽量避免使用；变量取值范围为-32768至+32767）
（1.12新增32位变量支持，但实际是使用相邻的两个16位变量，例如$$1相当于使用$1和$2，因而推荐仅使用$$1、$$3、$$5，并且使用$$1的时候就不要使用$1和$2，其它同理；32位变量取值范围为-2147483648至+2147483647）
（32位变量暂时只有联机模式可用）

【赋值】
语法：目标变量 = 值
语法：目标变量 = 来源变量

【含变量的基础语句】
输出：PRINT 用&amp;分隔的输出内容
（输出内容可以是多段，用&amp;分隔；每段内容如果是变量和常量会取其值，否则会按原样输出，留空会输出一个空格；如果最后一段内容为“\”则不换行，下一个Print会继续在本行输出）
按键：键位 变量名
（变量值作为持续时间，值&lt;=0则不按键）
摇杆：LS|RS 方向|角度 变量名
（变量值作为持续时间，值&lt;=0则不按键）
等待：WAIT 变量名
（变量值作为等待时间，值&lt;=0则不等待）

【含变量的循环】
语法：FOR 变量名
（变量值作为循环次数，值&lt;=0则直接跳过循环；循环开始后修改变量的值不会影响循环）
语法：FOR 循环变量 = 初始值|变量 TO 终止值|变量
（循环变量从初始值循环至终止值-1；循环开始后修改初始、终止变量不会影响循环）
循环控制：BREAK [层数]
（直接结束循环，层数&gt;1可以一次结束多层循环）
循环控制：CONTINUE [层数]
（跳过剩余内容继续下一轮循环，层数&gt;1可以跳出内层并继续外层循环）
示例：
$2 = 20
FOR $2                    # 循环20次
...
NEXT
FOR $1 = 5 TO $2    # 循环15次，$1分别取值5~19
...
NEXT

【条件分支】
语法：
IF 变量 比较运算符 变量|值
...
ELSE
...
ENDIF
（满足条件时执行第一个语句块，否则执行第二个语句块；可用的比较运算符有=、&lt;、&gt;、&lt;=、&gt;=、!=；ELSE和第二个语句块可以省略）
（注意，只有右侧可以用值，左侧必须用变量）
示例：
# 求1~100中的所有质数
FOR $1 = 2 TO 100    # 待测试数字
    FOR $2 = 2 TO $1    # 可能的约数
        $3 = $1
        $3 %= $2
        IF $3 = 0        # 找到一个约数，因此$1非质数，继续外层循环
            CONTINUE 2
        ENDIF
    NEXT
    PRINT $1
NEXT

【算术运算】
加法：目标变量 += 变量|值
乘法：目标变量 *= 变量|值
整除：目标变量 /= 变量|值
求余：目标变量 %= 变量|值
取负：目标变量 = -变量
示例：
_孵蛋箱数 = 10
$6 = _孵蛋箱数
$6 *= 30    # 孵蛋个数
FOR $1 = 0 TO $6
$2 = $1
$2 /= 30     # 箱数，以0为第一箱
$3 = $1
$3 %= 30
$3 /= 6     # 行数，以0为第一行
$4 = $1
$4 %= 6     # 列数，以0为第一列
PRINT $2 &amp; 箱 &amp; $3 &amp; 行 &amp; $4 &amp; 列
NEXT

【逻辑运算】
And：目标变量 &amp;= 变量|值
Or：目标变量 |= 变量|值
Xor：目标变量 ^= 变量|值
左移：目标变量 &lt;&lt;= 值
右移：目标变量 &gt;&gt;= 值
取反：目标变量 = ~变量

【栈操作】
入栈：PUSH 变量
出栈：POP 变量
全部入栈：PUSHALL
全部出栈：POPALL
（不懂什么是栈可以不用管，用于储存和恢复变量值，以及传递参数；全部入栈/出栈暂时只支持联机模式）

【转化布尔】
语法：BOOL 变量
（值为零则得到0，非零则得到1）

【随机数】
语法：RAND 变量
（生成一个随机数，取值范围为0~变量值-1，结果存入该变量）

&lt;To Be Continued...&gt;</value>
  </data>
  <metadata name="statusStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>132, 17</value>
  </metadata>
  <metadata name="openFileDialog1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>248, 17</value>
  </metadata>
  <metadata name="saveFileDialog1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>388, 17</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>69</value>
  </metadata>
</root>